diff --git a/mlir/include/mlir/Dialect/SCF/SCFOps.td b/mlir/include/mlir/Dialect/SCF/SCFOps.td
index 78aefec00bf..220d901fc8b 100644
--- a/mlir/include/mlir/Dialect/SCF/SCFOps.td
+++ b/mlir/include/mlir/Dialect/SCF/SCFOps.td
@@ -265,6 +265,8 @@ def IfOp : SCF_Op<"if",
                                : OpBuilder::atBlockEnd(body);
     }
   }];
+
+  let hasCanonicalizer = 1;
 }
 
 def ParallelOp : SCF_Op<"parallel",
diff --git a/mlir/lib/Dialect/SCF/SCF.cpp b/mlir/lib/Dialect/SCF/SCF.cpp
index 6f3f1e4dc0d..37f6bcb92f9 100644
--- a/mlir/lib/Dialect/SCF/SCF.cpp
+++ b/mlir/lib/Dialect/SCF/SCF.cpp
@@ -10,7 +10,12 @@
 #include "mlir/Dialect/StandardOps/IR/Ops.h"
 #include "mlir/IR/BlockAndValueMapping.h"
 #include "mlir/IR/PatternMatch.h"
+#include "mlir/IR/UseDefLists.h"
+#include "mlir/Support/LogicalResult.h"
 #include "mlir/Transforms/InliningUtils.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/iterator_range.h"
 
 using namespace mlir;
 using namespace mlir::scf;
@@ -508,6 +513,60 @@ void IfOp::getSuccessorRegions(Optional<unsigned> index,
   regions.push_back(RegionSuccessor(condition ? &thenRegion() : elseRegion));
 }
 
+namespace {
+// Remove results that have no use.
+struct RemoveUnusedResults : public OpRewritePattern<IfOp> {
+  using OpRewritePattern<IfOp>::OpRewritePattern;
+
+  LogicalResult matchAndRewrite(IfOp op,
+                                PatternRewriter &rewriter) const override {
+    // Compute indexes of the used results.
+    SmallVector<unsigned, 4> usedResults;
+    for (auto en : llvm::enumerate(op.getResults())) {
+      if (!en.value().use_empty())
+        usedResults.push_back(en.index());
+    }
+
+    // Only replace operations that have unused and used resutls.
+    if (usedResults.size() == op.getNumResults() || usedResults.size() == 0)
+      return failure();
+
+    // Walk all yield operations and remove the operands that have no use.
+    op.walk([&](YieldOp yieldOp) {
+      SmallVector<Value, 4> newOperands;
+      for(auto index : usedResults)
+        newOperands.push_back(yieldOp.getOperand(index));
+      rewriter.setInsertionPoint(yieldOp);
+      rewriter.replaceOpWithNewOp<YieldOp>(yieldOp, newOperands);
+    });
+    rewriter.setInsertionPoint(op);
+
+    // Create a new operation that returns only the used results.
+    SmallVector<Type, 4> newTypes;
+    for(auto index : usedResults)
+      newTypes.push_back(op.getResult(index).getType());
+    auto newOp =
+        rewriter.create<IfOp>(op.getLoc(), newTypes, op.condition(), true);
+    rewriter.mergeBlocks(op.getBody(0), newOp.getBody(0));
+    rewriter.mergeBlocks(op.getBody(1), newOp.getBody(1));
+
+    // Replace the old operation.
+    SmallVector<Value, 4> newResults(op.getNumResults(),
+                                     newOp.getResults().front());
+    for(auto en : llvm::enumerate(usedResults)) 
+      newResults[en.value()] = newOp.getResult(en.index()); 
+    rewriter.replaceOp(op, newResults);
+
+    return success();
+  }
+};
+} // namespace
+
+void IfOp::getCanonicalizationPatterns(OwningRewritePatternList &results,
+                                       MLIRContext *context) {
+  results.insert<RemoveUnusedResults>(context);
+}
+
 //===----------------------------------------------------------------------===//
 // ParallelOp
 //===----------------------------------------------------------------------===//
