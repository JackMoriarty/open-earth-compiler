diff --git a/mlir/include/mlir/Dialect/SCF/SCFOps.td b/mlir/include/mlir/Dialect/SCF/SCFOps.td
index 1011e0d7ef6..ee2c6cdb84a 100644
--- a/mlir/include/mlir/Dialect/SCF/SCFOps.td
+++ b/mlir/include/mlir/Dialect/SCF/SCFOps.td
@@ -262,6 +262,8 @@ def IfOp : SCF_Op<"if",
                                : OpBuilder::atBlockEnd(body);
     }
   }];
+
+  let hasCanonicalizer = 1;
 }
 
 def ParallelOp : SCF_Op<"parallel",
diff --git a/mlir/lib/Dialect/SCF/SCF.cpp b/mlir/lib/Dialect/SCF/SCF.cpp
index e36ffc2e6b8..c119ca59c42 100644
--- a/mlir/lib/Dialect/SCF/SCF.cpp
+++ b/mlir/lib/Dialect/SCF/SCF.cpp
@@ -9,8 +9,18 @@
 #include "mlir/Dialect/SCF/SCF.h"
 #include "mlir/Dialect/StandardOps/IR/Ops.h"
 #include "mlir/IR/BlockAndValueMapping.h"
+#include "mlir/IR/Builders.h"
+#include "mlir/IR/OperationSupport.h"
 #include "mlir/IR/PatternMatch.h"
+#include "mlir/IR/UseDefLists.h"
+#include "mlir/IR/Value.h"
+#include "mlir/Support/LogicalResult.h"
 #include "mlir/Transforms/InliningUtils.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/ADT/SmallVector.h"
+#include "llvm/ADT/iterator_range.h"
+#include <iterator>
+#include <string>
 
 using namespace mlir;
 using namespace mlir::scf;
@@ -508,6 +518,64 @@ void IfOp::getSuccessorRegions(Optional<unsigned> index,
   regions.push_back(RegionSuccessor(condition ? &thenRegion() : elseRegion));
 }
 
+namespace {
+// Remove results that have no use.
+struct RemoveUnusedResults : public OpRewritePattern<IfOp> {
+  using OpRewritePattern<IfOp>::OpRewritePattern;
+
+  LogicalResult matchAndRewrite(IfOp op,
+                                PatternRewriter &rewriter) const override {
+    // Only replace operations that return results.
+    if (op.getNumResults() == 0)
+      return failure();
+
+    // Compute the list of used results.
+    SmallVector<OpResult, 4> usedResults;
+    llvm::copy_if(op.getResults(), std::back_inserter(usedResults),
+                  [](OpResult result) { return !result.use_empty(); });
+
+    // Replace the operation if only a subset of its results have uses.
+    if (usedResults.size() < op.getNumResults()) {
+      // Compute the result types of the replacement operation.
+      SmallVector<Type, 4> newTypes;
+      llvm::transform(usedResults, std::back_inserter(newTypes),
+                      [](OpResult result) { return result.getType(); });
+
+      // Create the replacement operation and move the bodies
+      auto buildEmptyBody = [](OpBuilder &, Location) {};
+      auto newOp = rewriter.create<IfOp>(op.getLoc(), newTypes, op.condition(),
+                                         buildEmptyBody, buildEmptyBody);
+      rewriter.mergeBlocks(op.getBody(0), newOp.getBody(0));
+      rewriter.mergeBlocks(op.getBody(1), newOp.getBody(1));
+
+      // Walk the yield operations and remove the unused operands.
+      newOp.walk([&](scf::YieldOp yieldOp) {
+        SmallVector<Value, 4> usedOperands;
+        llvm::transform(usedResults, std::back_inserter(usedOperands),
+                        [&](OpResult result) {
+                          return yieldOp.getOperand(result.getResultNumber());
+                        });
+        rewriter.setInsertionPoint(yieldOp);
+        rewriter.replaceOpWithNewOp<scf::YieldOp>(yieldOp, usedOperands);
+      });
+
+      // Replace the operation by the new one.
+      SmallVector<Value, 4> repResults(op.getNumResults());
+      for (auto en : llvm::enumerate(usedResults)) 
+        repResults[en.value().getResultNumber()] = newOp.getResult(en.index());
+      rewriter.replaceOp(op, repResults);
+      success();
+    }
+    return failure();
+  }
+};
+} // namespace
+
+void IfOp::getCanonicalizationPatterns(OwningRewritePatternList &results,
+                                       MLIRContext *context) {
+  results.insert<RemoveUnusedResults>(context);
+}
+
 //===----------------------------------------------------------------------===//
 // ParallelOp
 //===----------------------------------------------------------------------===//
