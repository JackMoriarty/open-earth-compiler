diff --git a/mlir/lib/Conversion/LoopToStandard/ConvertLoopToStandard.cpp b/mlir/lib/Conversion/LoopToStandard/ConvertLoopToStandard.cpp
index a16c4a0c5cf..c9d1507bdd3 100644
--- a/mlir/lib/Conversion/LoopToStandard/ConvertLoopToStandard.cpp
+++ b/mlir/lib/Conversion/LoopToStandard/ConvertLoopToStandard.cpp
@@ -126,7 +126,7 @@ struct ForLowering : public OpRewritePattern<ForOp> {
 //      +--------------------------------+  |
 //      | then:                          |  |
 //      |   <then contents>              |  |
-//      |   br continue                  |  |
+//      |   br continue(%yields...)      |  |
 //      +--------------------------------+  |
 //             |                            |
 //   |----------               |-------------
@@ -134,13 +134,13 @@ struct ForLowering : public OpRewritePattern<ForOp> {
 //   |  +--------------------------------+
 //   |  | else:                          |
 //   |  |   <else contents>              |
-//   |  |   br continue                  |
+//   |  |   br continue(%yields...)      |
 //   |  +--------------------------------+
 //   |         |
 //   ------|   |
 //         v   v
 //      +--------------------------------+
-//      | continue:                      |
+//      | continue(%yields...):          |
 //      |   <code after the IfOp>        |
 //      +--------------------------------+
 //
@@ -236,13 +236,21 @@ IfLowering::matchAndRewrite(IfOp ifOp, PatternRewriter &rewriter) const {
   auto opPosition = rewriter.getInsertionPoint();
   auto *continueBlock = rewriter.splitBlock(condBlock, opPosition);
 
+  // Add the results of the if loop as block argument to the continuation block
+  for (auto result : ifOp.results())
+    result.replaceAllUsesWith(continueBlock->addArgument(result.getType()));
+
   // Move blocks from the "then" region to the region containing 'loop.if',
   // place it before the continuation block, and branch to it.
   auto &thenRegion = ifOp.thenRegion();
   auto *thenBlock = &thenRegion.front();
-  rewriter.eraseOp(thenRegion.back().getTerminator());
+  Operation *thenTerminator = thenRegion.back().getTerminator();
+  SmallVector<Value, 8> thenResults;
+  thenResults.append(thenTerminator->operand_begin(),
+                     thenTerminator->operand_end());
+  rewriter.eraseOp(thenTerminator);
   rewriter.setInsertionPointToEnd(&thenRegion.back());
-  rewriter.create<BranchOp>(loc, continueBlock);
+  rewriter.create<BranchOp>(loc, continueBlock, thenResults);
   rewriter.inlineRegionBefore(thenRegion, continueBlock);
 
   // Move blocks from the "else" region (if present) to the region containing
@@ -252,9 +260,13 @@ IfLowering::matchAndRewrite(IfOp ifOp, PatternRewriter &rewriter) const {
   auto &elseRegion = ifOp.elseRegion();
   if (!elseRegion.empty()) {
     elseBlock = &elseRegion.front();
-    rewriter.eraseOp(elseRegion.back().getTerminator());
+    Operation *elseTerminator = elseRegion.back().getTerminator();
+    SmallVector<Value, 8> elseResults;
+    elseResults.append(elseTerminator->operand_begin(),
+                       elseTerminator->operand_end());
+    rewriter.eraseOp(elseTerminator);
     rewriter.setInsertionPointToEnd(&elseRegion.back());
-    rewriter.create<BranchOp>(loc, continueBlock);
+    rewriter.create<BranchOp>(loc, continueBlock, elseResults);
     rewriter.inlineRegionBefore(elseRegion, continueBlock);
   }
 
diff --git a/mlir/test/Conversion/convert-to-cfg.mlir b/mlir/test/Conversion/convert-to-cfg.mlir
index 54c5d4c4a9c..658c389be32 100644
--- a/mlir/test/Conversion/convert-to-cfg.mlir
+++ b/mlir/test/Conversion/convert-to-cfg.mlir
@@ -81,6 +81,27 @@ func @simple_std_if_else(%arg0: i1) {
   return
 }
 
+// CHECK-LABEL: func @simple_yield_if_else(%{{.*}}: i1) -> (index, index) {
+//  CHECK-NEXT:   cond_br %{{.*}}, ^bb1, ^bb2
+//  CHECK-NEXT:   ^bb1:   // pred: ^bb0
+//  CHECK-NEXT:     [[C1:%.*]] = constant 1 : index
+//  CHECK-NEXT:     br ^bb3([[C1]], [[C1]] : index, index) 
+//  CHECK-NEXT:   ^bb2:   // pred: ^bb0
+//  CHECK-NEXT:     [[C2:%.*]] = constant 2 : index
+//  CHECK-NEXT:     br ^bb3([[C2]], [[C2]] : index, index) 
+//  CHECK-NEXT:   ^bb3([[R1:%.*]]: index, [[R2:%.*]]: index):   // 2 preds: ^bb1, ^bb2
+//  CHECK-NEXT:     return [[R1]], [[R2]] : index, index
+func @simple_yield_if_else(%arg0 : i1) -> (index, index) {
+  %result:2 = loop.if %arg0 -> (index, index) {
+    %c1 = constant 1 : index
+    loop.yield %c1, %c1 : index, index
+  } else {
+    %c2 = constant 2 : index
+    loop.yield %c2, %c2 : index, index
+  }
+  return %result#0, %result#1 : index, index
+}
+
 // CHECK-LABEL: func @simple_std_2_ifs(%{{.*}}: i1) {
 //  CHECK-NEXT:   cond_br %{{.*}}, ^bb1, ^bb5
 //  CHECK-NEXT: ^bb1:   // pred: ^bb0
